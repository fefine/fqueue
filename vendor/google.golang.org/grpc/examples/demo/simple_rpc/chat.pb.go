// Code generated by protoc-gen-go. DO NOT EDIT.
// source: chat.proto

/*
Package simple_rpc is a generated protocol buffer package.

It is generated from these files:
	chat.proto

It has these top-level messages:
	Msg
	MsgResp
*/
package simple_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MessageType int32

const (
	MessageType_PRIMARY MessageType = 0
	MessageType_GROUP   MessageType = 1
)

var MessageType_name = map[int32]string{
	0: "PRIMARY",
	1: "GROUP",
}
var MessageType_value = map[string]int32{
	"PRIMARY": 0,
	"GROUP":   1,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type RespType int32

const (
	RespType_OK    RespType = 0
	RespType_ERROR RespType = 1
)

var RespType_name = map[int32]string{
	0: "OK",
	1: "ERROR",
}
var RespType_value = map[string]int32{
	"OK":    0,
	"ERROR": 1,
}

func (x RespType) String() string {
	return proto.EnumName(RespType_name, int32(x))
}
func (RespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Msg struct {
	// from
	Fid int32 `protobuf:"varint,1,opt,name=fid" json:"fid,omitempty"`
	// to
	Tid int32 `protobuf:"varint,2,opt,name=tid" json:"tid,omitempty"`
	// message
	Msg string `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
	// type
	Type MessageType `protobuf:"varint,4,opt,name=type,enum=simple_rpc.MessageType" json:"type,omitempty"`
	// send time
	Time int64 `protobuf:"varint,5,opt,name=time" json:"time,omitempty"`
}

func (m *Msg) Reset()                    { *m = Msg{} }
func (m *Msg) String() string            { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()               {}
func (*Msg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Msg) GetFid() int32 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *Msg) GetTid() int32 {
	if m != nil {
		return m.Tid
	}
	return 0
}

func (m *Msg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Msg) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageType_PRIMARY
}

func (m *Msg) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type MsgResp struct {
	Type RespType `protobuf:"varint,1,opt,name=type,enum=simple_rpc.RespType" json:"type,omitempty"`
	// if type == error, resp is error msg
	Resp string `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *MsgResp) Reset()                    { *m = MsgResp{} }
func (m *MsgResp) String() string            { return proto.CompactTextString(m) }
func (*MsgResp) ProtoMessage()               {}
func (*MsgResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MsgResp) GetType() RespType {
	if m != nil {
		return m.Type
	}
	return RespType_OK
}

func (m *MsgResp) GetResp() string {
	if m != nil {
		return m.Resp
	}
	return ""
}

func init() {
	proto.RegisterType((*Msg)(nil), "simple_rpc.Msg")
	proto.RegisterType((*MsgResp)(nil), "simple_rpc.MsgResp")
	proto.RegisterEnum("simple_rpc.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("simple_rpc.RespType", RespType_name, RespType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ChatServer service

type ChatServerClient interface {
	Send(ctx context.Context, in *Msg, opts ...grpc.CallOption) (*MsgResp, error)
	SendStream(ctx context.Context, opts ...grpc.CallOption) (ChatServer_SendStreamClient, error)
	RecvStream(ctx context.Context, in *Msg, opts ...grpc.CallOption) (ChatServer_RecvStreamClient, error)
	AllStream(ctx context.Context, opts ...grpc.CallOption) (ChatServer_AllStreamClient, error)
}

type chatServerClient struct {
	cc *grpc.ClientConn
}

func NewChatServerClient(cc *grpc.ClientConn) ChatServerClient {
	return &chatServerClient{cc}
}

func (c *chatServerClient) Send(ctx context.Context, in *Msg, opts ...grpc.CallOption) (*MsgResp, error) {
	out := new(MsgResp)
	err := grpc.Invoke(ctx, "/simple_rpc.ChatServer/Send", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServerClient) SendStream(ctx context.Context, opts ...grpc.CallOption) (ChatServer_SendStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChatServer_serviceDesc.Streams[0], c.cc, "/simple_rpc.ChatServer/SendStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatServerSendStreamClient{stream}
	return x, nil
}

type ChatServer_SendStreamClient interface {
	Send(*Msg) error
	CloseAndRecv() (*MsgResp, error)
	grpc.ClientStream
}

type chatServerSendStreamClient struct {
	grpc.ClientStream
}

func (x *chatServerSendStreamClient) Send(m *Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chatServerSendStreamClient) CloseAndRecv() (*MsgResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(MsgResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chatServerClient) RecvStream(ctx context.Context, in *Msg, opts ...grpc.CallOption) (ChatServer_RecvStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChatServer_serviceDesc.Streams[1], c.cc, "/simple_rpc.ChatServer/RecvStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatServerRecvStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChatServer_RecvStreamClient interface {
	Recv() (*MsgResp, error)
	grpc.ClientStream
}

type chatServerRecvStreamClient struct {
	grpc.ClientStream
}

func (x *chatServerRecvStreamClient) Recv() (*MsgResp, error) {
	m := new(MsgResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chatServerClient) AllStream(ctx context.Context, opts ...grpc.CallOption) (ChatServer_AllStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChatServer_serviceDesc.Streams[2], c.cc, "/simple_rpc.ChatServer/AllStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatServerAllStreamClient{stream}
	return x, nil
}

type ChatServer_AllStreamClient interface {
	Send(*Msg) error
	Recv() (*MsgResp, error)
	grpc.ClientStream
}

type chatServerAllStreamClient struct {
	grpc.ClientStream
}

func (x *chatServerAllStreamClient) Send(m *Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chatServerAllStreamClient) Recv() (*MsgResp, error) {
	m := new(MsgResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ChatServer service

type ChatServerServer interface {
	Send(context.Context, *Msg) (*MsgResp, error)
	SendStream(ChatServer_SendStreamServer) error
	RecvStream(*Msg, ChatServer_RecvStreamServer) error
	AllStream(ChatServer_AllStreamServer) error
}

func RegisterChatServerServer(s *grpc.Server, srv ChatServerServer) {
	s.RegisterService(&_ChatServer_serviceDesc, srv)
}

func _ChatServer_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Msg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServerServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/simple_rpc.ChatServer/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServerServer).Send(ctx, req.(*Msg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatServer_SendStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServerServer).SendStream(&chatServerSendStreamServer{stream})
}

type ChatServer_SendStreamServer interface {
	SendAndClose(*MsgResp) error
	Recv() (*Msg, error)
	grpc.ServerStream
}

type chatServerSendStreamServer struct {
	grpc.ServerStream
}

func (x *chatServerSendStreamServer) SendAndClose(m *MsgResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chatServerSendStreamServer) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ChatServer_RecvStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Msg)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServerServer).RecvStream(m, &chatServerRecvStreamServer{stream})
}

type ChatServer_RecvStreamServer interface {
	Send(*MsgResp) error
	grpc.ServerStream
}

type chatServerRecvStreamServer struct {
	grpc.ServerStream
}

func (x *chatServerRecvStreamServer) Send(m *MsgResp) error {
	return x.ServerStream.SendMsg(m)
}

func _ChatServer_AllStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServerServer).AllStream(&chatServerAllStreamServer{stream})
}

type ChatServer_AllStreamServer interface {
	Send(*MsgResp) error
	Recv() (*Msg, error)
	grpc.ServerStream
}

type chatServerAllStreamServer struct {
	grpc.ServerStream
}

func (x *chatServerAllStreamServer) Send(m *MsgResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chatServerAllStreamServer) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ChatServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "simple_rpc.ChatServer",
	HandlerType: (*ChatServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _ChatServer_Send_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendStream",
			Handler:       _ChatServer_SendStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "RecvStream",
			Handler:       _ChatServer_RecvStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AllStream",
			Handler:       _ChatServer_AllStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "chat.proto",
}

func init() { proto.RegisterFile("chat.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 299 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xd1, 0x4b, 0xc2, 0x50,
	0x14, 0xc6, 0x3d, 0x6e, 0x6a, 0x3b, 0x42, 0x8d, 0x53, 0xd0, 0x08, 0x82, 0x21, 0x04, 0xc3, 0x60,
	0x88, 0x41, 0x3d, 0x4b, 0x84, 0x44, 0x0c, 0xe5, 0x58, 0x0f, 0x3d, 0xc5, 0xd2, 0xd3, 0x1c, 0xb8,
	0xbc, 0xec, 0x5e, 0x04, 0xa1, 0x7f, 0xb7, 0xff, 0x23, 0xee, 0x2c, 0xd2, 0x9e, 0xf2, 0xed, 0xe3,
	0x3b, 0xe7, 0xfb, 0x7d, 0xf7, 0xc2, 0x41, 0x9c, 0xce, 0x53, 0x13, 0xab, 0x72, 0x69, 0x96, 0x84,
	0x3a, 0x2f, 0xd4, 0x42, 0x5e, 0x4a, 0x35, 0xed, 0x7c, 0xa0, 0x93, 0xe8, 0x8c, 0x7c, 0x74, 0xde,
	0xf2, 0x59, 0x00, 0x21, 0x44, 0x0d, 0xb6, 0xd2, 0x3a, 0x26, 0x9f, 0x05, 0xf5, 0x8d, 0x63, 0x36,
	0x4e, 0xa1, 0xb3, 0xc0, 0x09, 0x21, 0xf2, 0xd8, 0x4a, 0xba, 0x44, 0xd7, 0xac, 0x95, 0x04, 0x6e,
	0x08, 0xd1, 0x61, 0xff, 0x34, 0xfe, 0xe5, 0xc6, 0x89, 0x68, 0x9d, 0x66, 0xf2, 0xb8, 0x56, 0xc2,
	0xd5, 0x12, 0x11, 0xba, 0x26, 0x2f, 0x24, 0x68, 0x84, 0x10, 0x39, 0x5c, 0xe9, 0xce, 0x10, 0x5b,
	0x89, 0xce, 0x58, 0xb4, 0xa2, 0xe8, 0x9b, 0x05, 0x15, 0xeb, 0x64, 0x9b, 0x65, 0xe7, 0xbb, 0xa0,
	0x52, 0xb4, 0xaa, 0x9e, 0xe6, 0x71, 0xa5, 0xbb, 0x17, 0xd8, 0xde, 0x6a, 0xa4, 0x36, 0xb6, 0xc6,
	0x7c, 0x9f, 0x0c, 0xf8, 0xd9, 0xaf, 0x91, 0x87, 0x8d, 0x21, 0x8f, 0x9e, 0xc6, 0x3e, 0x74, 0xcf,
	0xf1, 0xe0, 0x07, 0x46, 0x4d, 0xac, 0x8f, 0x1e, 0x36, 0xe3, 0x3b, 0xe6, 0x11, 0xfb, 0xd0, 0xff,
	0x04, 0xc4, 0xdb, 0x79, 0x6a, 0x26, 0x52, 0xae, 0xa4, 0xa4, 0x18, 0xdd, 0x89, 0xbc, 0xcf, 0xe8,
	0x68, 0xe7, 0x63, 0x3a, 0x3b, 0x3b, 0xfe, 0x63, 0x58, 0x66, 0xa7, 0x46, 0xd7, 0x88, 0x76, 0x7f,
	0x62, 0x4a, 0x49, 0x8b, 0xff, 0xa6, 0x22, 0xb0, 0x39, 0x96, 0xe9, 0x6a, 0xbf, 0x5c, 0x0f, 0xe8,
	0x06, 0xbd, 0xc1, 0x62, 0xb1, 0x6f, 0x5d, 0x0f, 0x5e, 0x9b, 0xd5, 0x1d, 0x5c, 0x7d, 0x05, 0x00,
	0x00, 0xff, 0xff, 0x06, 0xe9, 0xdc, 0xf4, 0x15, 0x02, 0x00, 0x00,
}
