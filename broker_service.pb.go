// Code generated by protoc-gen-go. DO NOT EDIT.
// source: broker_service.proto

/*
Package fqueue is a generated protocol buffer package.

It is generated from these files:
	broker_service.proto

It has these top-level messages:
	MsgBatch
	GetReq
	GetResp
	SubReq
	SubResp
	PullReq
	CreateTopicReq
	AssignTopicReq
	TopicPartition
	TopicPartitionOffset
	TopicPartitionLeader
	Resp
*/
package fqueue

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 响应的状态
type RespStatus int32

const (
	RespStatus_OK    RespStatus = 0
	RespStatus_ERROR RespStatus = 1
)

var RespStatus_name = map[int32]string{
	0: "OK",
	1: "ERROR",
}
var RespStatus_value = map[string]int32{
	"OK":    0,
	"ERROR": 1,
}

func (x RespStatus) String() string {
	return proto.EnumName(RespStatus_name, int32(x))
}
func (RespStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// 一次发送单个分区的多个消息
type MsgBatch struct {
	Topic       string   `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	Partition   uint32   `protobuf:"varint,2,opt,name=partition" json:"partition,omitempty"`
	StartOffset uint64   `protobuf:"varint,3,opt,name=startOffset" json:"startOffset,omitempty"`
	Msgs        [][]byte `protobuf:"bytes,4,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *MsgBatch) Reset()                    { *m = MsgBatch{} }
func (m *MsgBatch) String() string            { return proto.CompactTextString(m) }
func (*MsgBatch) ProtoMessage()               {}
func (*MsgBatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *MsgBatch) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *MsgBatch) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *MsgBatch) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *MsgBatch) GetMsgs() [][]byte {
	if m != nil {
		return m.Msgs
	}
	return nil
}

// 获取缺失的消息
type GetReq struct {
	Topic       string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	Partition   uint32 `protobuf:"varint,2,opt,name=partition" json:"partition,omitempty"`
	StartOffset uint64 `protobuf:"varint,3,opt,name=startOffset" json:"startOffset,omitempty"`
}

func (m *GetReq) Reset()                    { *m = GetReq{} }
func (m *GetReq) String() string            { return proto.CompactTextString(m) }
func (*GetReq) ProtoMessage()               {}
func (*GetReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetReq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *GetReq) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *GetReq) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

// get请求的resp
type GetResp struct {
	Resp *Resp     `protobuf:"bytes,1,opt,name=resp" json:"resp,omitempty"`
	Msgs *MsgBatch `protobuf:"bytes,2,opt,name=msgs" json:"msgs,omitempty"`
	// 如果跟上, 则不用继续发get
	Enough bool `protobuf:"varint,3,opt,name=enough" json:"enough,omitempty"`
}

func (m *GetResp) Reset()                    { *m = GetResp{} }
func (m *GetResp) String() string            { return proto.CompactTextString(m) }
func (*GetResp) ProtoMessage()               {}
func (*GetResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetResp) GetResp() *Resp {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *GetResp) GetMsgs() *MsgBatch {
	if m != nil {
		return m.Msgs
	}
	return nil
}

func (m *GetResp) GetEnough() bool {
	if m != nil {
		return m.Enough
	}
	return false
}

// 订阅, 默认从最新位置开始读取
type SubReq struct {
	Topics        []string `protobuf:"bytes,1,rep,name=topics" json:"topics,omitempty"`
	CousumerGroup string   `protobuf:"bytes,2,opt,name=cousumerGroup" json:"cousumerGroup,omitempty"`
	ConsumerId    string   `protobuf:"bytes,3,opt,name=consumerId" json:"consumerId,omitempty"`
}

func (m *SubReq) Reset()                    { *m = SubReq{} }
func (m *SubReq) String() string            { return proto.CompactTextString(m) }
func (*SubReq) ProtoMessage()               {}
func (*SubReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SubReq) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func (m *SubReq) GetCousumerGroup() string {
	if m != nil {
		return m.CousumerGroup
	}
	return ""
}

func (m *SubReq) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

type SubResp struct {
	Resp *Resp `protobuf:"bytes,1,opt,name=resp" json:"resp,omitempty"`
	// 分配给它的topic, partition
	TopicPartitionLeaders []*TopicPartitionLeader `protobuf:"bytes,2,rep,name=topicPartitionLeaders" json:"topicPartitionLeaders,omitempty"`
}

func (m *SubResp) Reset()                    { *m = SubResp{} }
func (m *SubResp) String() string            { return proto.CompactTextString(m) }
func (*SubResp) ProtoMessage()               {}
func (*SubResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SubResp) GetResp() *Resp {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *SubResp) GetTopicPartitionLeaders() []*TopicPartitionLeader {
	if m != nil {
		return m.TopicPartitionLeaders
	}
	return nil
}

type PullReq struct {
	Count uint32 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	// 超时时间, ms, <=0代表立即返回
	Timeout int64 `protobuf:"varint,2,opt,name=timeout" json:"timeout,omitempty"`
	// 这些信息由客户端存储
	TpSet *TopicPartitionOffset `protobuf:"bytes,3,opt,name=tpSet" json:"tpSet,omitempty"`
}

func (m *PullReq) Reset()                    { *m = PullReq{} }
func (m *PullReq) String() string            { return proto.CompactTextString(m) }
func (*PullReq) ProtoMessage()               {}
func (*PullReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PullReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PullReq) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *PullReq) GetTpSet() *TopicPartitionOffset {
	if m != nil {
		return m.TpSet
	}
	return nil
}

type CreateTopicReq struct {
	Topic          string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	PartitionCount uint32 `protobuf:"varint,2,opt,name=partitionCount" json:"partitionCount,omitempty"`
	ReplicaCount   uint32 `protobuf:"varint,3,opt,name=replicaCount" json:"replicaCount,omitempty"`
}

func (m *CreateTopicReq) Reset()                    { *m = CreateTopicReq{} }
func (m *CreateTopicReq) String() string            { return proto.CompactTextString(m) }
func (*CreateTopicReq) ProtoMessage()               {}
func (*CreateTopicReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *CreateTopicReq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *CreateTopicReq) GetPartitionCount() uint32 {
	if m != nil {
		return m.PartitionCount
	}
	return 0
}

func (m *CreateTopicReq) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

type AssignTopicReq struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	// 需要新建的分区 eg: [1, 3, 4]
	Partitions []uint32 `protobuf:"varint,2,rep,packed,name=partitions" json:"partitions,omitempty"`
	// 由接收此消息的broker做leader的partition, eg: [1, 4]
	LeaderPartitions []uint32 `protobuf:"varint,3,rep,packed,name=leaderPartitions" json:"leaderPartitions,omitempty"`
}

func (m *AssignTopicReq) Reset()                    { *m = AssignTopicReq{} }
func (m *AssignTopicReq) String() string            { return proto.CompactTextString(m) }
func (*AssignTopicReq) ProtoMessage()               {}
func (*AssignTopicReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *AssignTopicReq) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *AssignTopicReq) GetPartitions() []uint32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *AssignTopicReq) GetLeaderPartitions() []uint32 {
	if m != nil {
		return m.LeaderPartitions
	}
	return nil
}

type TopicPartition struct {
	Topic     string   `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	Partition []uint32 `protobuf:"varint,2,rep,packed,name=partition" json:"partition,omitempty"`
}

func (m *TopicPartition) Reset()                    { *m = TopicPartition{} }
func (m *TopicPartition) String() string            { return proto.CompactTextString(m) }
func (*TopicPartition) ProtoMessage()               {}
func (*TopicPartition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *TopicPartition) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *TopicPartition) GetPartition() []uint32 {
	if m != nil {
		return m.Partition
	}
	return nil
}

type TopicPartitionOffset struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	// partition, offset
	PartitionOffset map[uint32]uint64 `protobuf:"bytes,2,rep,name=partitionOffset" json:"partitionOffset,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *TopicPartitionOffset) Reset()                    { *m = TopicPartitionOffset{} }
func (m *TopicPartitionOffset) String() string            { return proto.CompactTextString(m) }
func (*TopicPartitionOffset) ProtoMessage()               {}
func (*TopicPartitionOffset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *TopicPartitionOffset) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *TopicPartitionOffset) GetPartitionOffset() map[uint32]uint64 {
	if m != nil {
		return m.PartitionOffset
	}
	return nil
}

type TopicPartitionLeader struct {
	Topic           string            `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	PartitionLeader map[uint32]string `protobuf:"bytes,2,rep,name=partitionLeader" json:"partitionLeader,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TopicPartitionLeader) Reset()                    { *m = TopicPartitionLeader{} }
func (m *TopicPartitionLeader) String() string            { return proto.CompactTextString(m) }
func (*TopicPartitionLeader) ProtoMessage()               {}
func (*TopicPartitionLeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *TopicPartitionLeader) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *TopicPartitionLeader) GetPartitionLeader() map[uint32]string {
	if m != nil {
		return m.PartitionLeader
	}
	return nil
}

type Resp struct {
	Status  RespStatus `protobuf:"varint,1,opt,name=status,enum=fqueue.RespStatus" json:"status,omitempty"`
	Comment string     `protobuf:"bytes,2,opt,name=comment" json:"comment,omitempty"`
}

func (m *Resp) Reset()                    { *m = Resp{} }
func (m *Resp) String() string            { return proto.CompactTextString(m) }
func (*Resp) ProtoMessage()               {}
func (*Resp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Resp) GetStatus() RespStatus {
	if m != nil {
		return m.Status
	}
	return RespStatus_OK
}

func (m *Resp) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgBatch)(nil), "fqueue.MsgBatch")
	proto.RegisterType((*GetReq)(nil), "fqueue.GetReq")
	proto.RegisterType((*GetResp)(nil), "fqueue.GetResp")
	proto.RegisterType((*SubReq)(nil), "fqueue.SubReq")
	proto.RegisterType((*SubResp)(nil), "fqueue.SubResp")
	proto.RegisterType((*PullReq)(nil), "fqueue.PullReq")
	proto.RegisterType((*CreateTopicReq)(nil), "fqueue.CreateTopicReq")
	proto.RegisterType((*AssignTopicReq)(nil), "fqueue.AssignTopicReq")
	proto.RegisterType((*TopicPartition)(nil), "fqueue.TopicPartition")
	proto.RegisterType((*TopicPartitionOffset)(nil), "fqueue.TopicPartitionOffset")
	proto.RegisterType((*TopicPartitionLeader)(nil), "fqueue.TopicPartitionLeader")
	proto.RegisterType((*Resp)(nil), "fqueue.Resp")
	proto.RegisterEnum("fqueue.RespStatus", RespStatus_name, RespStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BrokerService service

type BrokerServiceClient interface {
	// broker
	// append from other broker
	Append(ctx context.Context, opts ...grpc.CallOption) (BrokerService_AppendClient, error)
	// get msg
	Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error)
	// producer
	Push(ctx context.Context, opts ...grpc.CallOption) (BrokerService_PushClient, error)
	// 创建分区
	CreateTopic(ctx context.Context, in *CreateTopicReq, opts ...grpc.CallOption) (*Resp, error)
	// 分配分区
	AssignTopic(ctx context.Context, in *AssignTopicReq, opts ...grpc.CallOption) (*Resp, error)
	// consumer
	// subscribe topics
	Subscribe(ctx context.Context, in *SubReq, opts ...grpc.CallOption) (*SubResp, error)
	// Producer pull msg
	Pull(ctx context.Context, in *PullReq, opts ...grpc.CallOption) (BrokerService_PullClient, error)
}

type brokerServiceClient struct {
	cc *grpc.ClientConn
}

func NewBrokerServiceClient(cc *grpc.ClientConn) BrokerServiceClient {
	return &brokerServiceClient{cc}
}

func (c *brokerServiceClient) Append(ctx context.Context, opts ...grpc.CallOption) (BrokerService_AppendClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[0], c.cc, "/fqueue.BrokerService/Append", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceAppendClient{stream}
	return x, nil
}

type BrokerService_AppendClient interface {
	Send(*MsgBatch) error
	CloseAndRecv() (*Resp, error)
	grpc.ClientStream
}

type brokerServiceAppendClient struct {
	grpc.ClientStream
}

func (x *brokerServiceAppendClient) Send(m *MsgBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerServiceAppendClient) CloseAndRecv() (*Resp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Resp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error) {
	out := new(GetResp)
	err := grpc.Invoke(ctx, "/fqueue.BrokerService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Push(ctx context.Context, opts ...grpc.CallOption) (BrokerService_PushClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[1], c.cc, "/fqueue.BrokerService/Push", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServicePushClient{stream}
	return x, nil
}

type BrokerService_PushClient interface {
	Send(*MsgBatch) error
	CloseAndRecv() (*Resp, error)
	grpc.ClientStream
}

type brokerServicePushClient struct {
	grpc.ClientStream
}

func (x *brokerServicePushClient) Send(m *MsgBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerServicePushClient) CloseAndRecv() (*Resp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Resp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) CreateTopic(ctx context.Context, in *CreateTopicReq, opts ...grpc.CallOption) (*Resp, error) {
	out := new(Resp)
	err := grpc.Invoke(ctx, "/fqueue.BrokerService/CreateTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) AssignTopic(ctx context.Context, in *AssignTopicReq, opts ...grpc.CallOption) (*Resp, error) {
	out := new(Resp)
	err := grpc.Invoke(ctx, "/fqueue.BrokerService/AssignTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Subscribe(ctx context.Context, in *SubReq, opts ...grpc.CallOption) (*SubResp, error) {
	out := new(SubResp)
	err := grpc.Invoke(ctx, "/fqueue.BrokerService/Subscribe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Pull(ctx context.Context, in *PullReq, opts ...grpc.CallOption) (BrokerService_PullClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[2], c.cc, "/fqueue.BrokerService/Pull", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServicePullClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_PullClient interface {
	Recv() (*MsgBatch, error)
	grpc.ClientStream
}

type brokerServicePullClient struct {
	grpc.ClientStream
}

func (x *brokerServicePullClient) Recv() (*MsgBatch, error) {
	m := new(MsgBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BrokerService service

type BrokerServiceServer interface {
	// broker
	// append from other broker
	Append(BrokerService_AppendServer) error
	// get msg
	Get(context.Context, *GetReq) (*GetResp, error)
	// producer
	Push(BrokerService_PushServer) error
	// 创建分区
	CreateTopic(context.Context, *CreateTopicReq) (*Resp, error)
	// 分配分区
	AssignTopic(context.Context, *AssignTopicReq) (*Resp, error)
	// consumer
	// subscribe topics
	Subscribe(context.Context, *SubReq) (*SubResp, error)
	// Producer pull msg
	Pull(*PullReq, BrokerService_PullServer) error
}

func RegisterBrokerServiceServer(s *grpc.Server, srv BrokerServiceServer) {
	s.RegisterService(&_BrokerService_serviceDesc, srv)
}

func _BrokerService_Append_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServiceServer).Append(&brokerServiceAppendServer{stream})
}

type BrokerService_AppendServer interface {
	SendAndClose(*Resp) error
	Recv() (*MsgBatch, error)
	grpc.ServerStream
}

type brokerServiceAppendServer struct {
	grpc.ServerStream
}

func (x *brokerServiceAppendServer) SendAndClose(m *Resp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerServiceAppendServer) Recv() (*MsgBatch, error) {
	m := new(MsgBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BrokerService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fqueue.BrokerService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Get(ctx, req.(*GetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Push_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServiceServer).Push(&brokerServicePushServer{stream})
}

type BrokerService_PushServer interface {
	SendAndClose(*Resp) error
	Recv() (*MsgBatch, error)
	grpc.ServerStream
}

type brokerServicePushServer struct {
	grpc.ServerStream
}

func (x *brokerServicePushServer) SendAndClose(m *Resp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerServicePushServer) Recv() (*MsgBatch, error) {
	m := new(MsgBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BrokerService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fqueue.BrokerService/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).CreateTopic(ctx, req.(*CreateTopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_AssignTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignTopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).AssignTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fqueue.BrokerService/AssignTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).AssignTopic(ctx, req.(*AssignTopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fqueue.BrokerService/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Subscribe(ctx, req.(*SubReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Pull_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PullReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).Pull(m, &brokerServicePullServer{stream})
}

type BrokerService_PullServer interface {
	Send(*MsgBatch) error
	grpc.ServerStream
}

type brokerServicePullServer struct {
	grpc.ServerStream
}

func (x *brokerServicePullServer) Send(m *MsgBatch) error {
	return x.ServerStream.SendMsg(m)
}

var _BrokerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fqueue.BrokerService",
	HandlerType: (*BrokerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _BrokerService_Get_Handler,
		},
		{
			MethodName: "CreateTopic",
			Handler:    _BrokerService_CreateTopic_Handler,
		},
		{
			MethodName: "AssignTopic",
			Handler:    _BrokerService_AssignTopic_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _BrokerService_Subscribe_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Append",
			Handler:       _BrokerService_Append_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Push",
			Handler:       _BrokerService_Push_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Pull",
			Handler:       _BrokerService_Pull_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "broker_service.proto",
}

func init() { proto.RegisterFile("broker_service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 701 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xdd, 0x6a, 0xdb, 0x4a,
	0x10, 0xb6, 0x2c, 0x47, 0x8e, 0xc6, 0xb1, 0x63, 0x06, 0x9f, 0x60, 0x4c, 0xc8, 0x31, 0x22, 0x1c,
	0x84, 0x39, 0x35, 0xad, 0x4b, 0xa1, 0xf4, 0x2e, 0x49, 0x43, 0x28, 0x4d, 0x89, 0x59, 0xf7, 0xae,
	0xd0, 0x22, 0x2b, 0x6b, 0x47, 0x44, 0x96, 0x94, 0xfd, 0x09, 0xe4, 0xaa, 0x4f, 0xd8, 0x77, 0xe8,
	0xa3, 0x14, 0xed, 0x4a, 0xb1, 0x64, 0x3b, 0x89, 0x6f, 0x7a, 0xa7, 0x99, 0xfd, 0xe6, 0xe7, 0x9b,
	0x3f, 0x41, 0x67, 0xca, 0xe2, 0x5b, 0xca, 0x7e, 0x70, 0xca, 0xee, 0x03, 0x9f, 0x0e, 0x13, 0x16,
	0x8b, 0x18, 0xad, 0xd9, 0x9d, 0xa4, 0x92, 0x3a, 0x02, 0x76, 0xbf, 0xf0, 0xf9, 0xa9, 0x27, 0xfc,
	0x1b, 0xec, 0xc0, 0x8e, 0x88, 0x93, 0xc0, 0xef, 0x1a, 0x7d, 0xc3, 0xb5, 0x89, 0x16, 0xf0, 0x10,
	0xec, 0xc4, 0x63, 0x22, 0x10, 0x41, 0x1c, 0x75, 0xab, 0x7d, 0xc3, 0x6d, 0x92, 0xa5, 0x02, 0xfb,
	0xd0, 0xe0, 0xc2, 0x63, 0xe2, 0x6a, 0x36, 0xe3, 0x54, 0x74, 0xcd, 0xbe, 0xe1, 0xd6, 0x48, 0x51,
	0x85, 0x08, 0xb5, 0x05, 0x9f, 0xf3, 0x6e, 0xad, 0x6f, 0xba, 0x7b, 0x44, 0x7d, 0x3b, 0xdf, 0xc1,
	0xba, 0xa0, 0x82, 0xd0, 0xbb, 0xbf, 0x13, 0xd3, 0x09, 0xa0, 0xae, 0xfc, 0xf3, 0x04, 0xfb, 0x50,
	0x63, 0x94, 0x27, 0xca, 0x7f, 0x63, 0xb4, 0x37, 0xd4, 0xbc, 0x87, 0xe9, 0x1b, 0x51, 0x2f, 0x78,
	0x9c, 0x25, 0x58, 0x55, 0x88, 0x76, 0x8e, 0xc8, 0xcb, 0xa2, 0x53, 0xc6, 0x03, 0xb0, 0x68, 0x14,
	0xcb, 0xf9, 0x8d, 0x8a, 0xb7, 0x4b, 0x32, 0xc9, 0x99, 0x81, 0x35, 0x91, 0xd3, 0x94, 0xca, 0x01,
	0x58, 0x2a, 0x7b, 0xde, 0x35, 0xfa, 0xa6, 0x6b, 0x93, 0x4c, 0xc2, 0x63, 0x68, 0xfa, 0xb1, 0xe4,
	0x72, 0x41, 0xd9, 0x05, 0x8b, 0x65, 0xa2, 0x02, 0xd9, 0xa4, 0xac, 0xc4, 0x23, 0x00, 0x3f, 0x8e,
	0x94, 0xe2, 0xd3, 0xb5, 0x8a, 0x61, 0x93, 0x82, 0xc6, 0xf9, 0x09, 0x75, 0x15, 0x67, 0x2b, 0x4a,
	0x04, 0xfe, 0x51, 0xc1, 0xc7, 0x79, 0xcd, 0x2e, 0xa9, 0x77, 0x4d, 0x59, 0xca, 0xd1, 0x74, 0x1b,
	0xa3, 0xc3, 0xdc, 0xe4, 0xeb, 0x06, 0x10, 0xd9, 0x6c, 0xea, 0x2c, 0xa0, 0x3e, 0x96, 0x61, 0x98,
	0x35, 0xcd, 0x8f, 0x65, 0x24, 0x54, 0x06, 0x4d, 0xa2, 0x05, 0xec, 0x42, 0x5d, 0x04, 0x0b, 0x1a,
	0x4b, 0xa1, 0x18, 0x9a, 0x24, 0x17, 0x71, 0x04, 0x3b, 0x22, 0x99, 0x64, 0xad, 0x7a, 0x32, 0xbc,
	0xee, 0x1d, 0xd1, 0x50, 0x87, 0x41, 0xeb, 0x8c, 0x51, 0x4f, 0x50, 0x05, 0x7a, 0x7a, 0x54, 0xfe,
	0x83, 0xd6, 0xe3, 0x64, 0x9c, 0xa9, 0xa4, 0xf4, 0xbc, 0xac, 0x68, 0xd1, 0x81, 0x3d, 0x46, 0x93,
	0x30, 0xf0, 0x3d, 0x8d, 0x32, 0x15, 0xaa, 0xa4, 0x4b, 0x63, 0x9e, 0x70, 0x1e, 0xcc, 0xa3, 0x17,
	0x62, 0x1e, 0x01, 0x3c, 0x7a, 0xd7, 0x35, 0x6d, 0x92, 0x82, 0x06, 0x07, 0xd0, 0x0e, 0x55, 0xd5,
	0xc6, 0x4b, 0x94, 0xa9, 0x50, 0x6b, 0x7a, 0xe7, 0x23, 0xb4, 0xca, 0x65, 0xd8, 0x6e, 0x25, 0xcc,
	0xd2, 0x4a, 0x38, 0xbf, 0x0c, 0xe8, 0x6c, 0xaa, 0xe6, 0x13, 0xce, 0xbe, 0xc1, 0x7e, 0x52, 0x06,
	0x66, 0x93, 0xf1, 0xe6, 0xb9, 0xd6, 0x0c, 0x57, 0xe4, 0xf3, 0x48, 0xb0, 0x07, 0xb2, 0xea, 0xa9,
	0x77, 0x0a, 0x9d, 0x4d, 0x40, 0x6c, 0x83, 0x79, 0x4b, 0x1f, 0xb2, 0x99, 0x49, 0x3f, 0xd3, 0xe4,
	0xee, 0xbd, 0x50, 0x52, 0xd5, 0xb2, 0x1a, 0xd1, 0xc2, 0x87, 0xea, 0x7b, 0x63, 0x03, 0x1f, 0x3d,
	0x86, 0x5b, 0xf0, 0xd1, 0xc0, 0xe7, 0xf9, 0x68, 0xcc, 0x70, 0x45, 0x5e, 0xe5, 0xa3, 0xb5, 0x25,
	0x3e, 0x05, 0xe0, 0x4b, 0x7c, 0xec, 0x22, 0x9f, 0x4b, 0xa8, 0xa9, 0xd5, 0x1d, 0x80, 0xc5, 0x85,
	0x27, 0x24, 0x57, 0x66, 0xad, 0x11, 0x16, 0x97, 0x77, 0xa2, 0x5e, 0x48, 0x86, 0x48, 0xf7, 0xc9,
	0x8f, 0x17, 0x0b, 0x9a, 0x8d, 0xb4, 0x4d, 0x72, 0x71, 0xf0, 0x2f, 0xc0, 0x12, 0x8f, 0x16, 0x54,
	0xaf, 0x3e, 0xb7, 0x2b, 0x68, 0xc3, 0xce, 0x39, 0x21, 0x57, 0xa4, 0x6d, 0x8c, 0x7e, 0x57, 0xa1,
	0x79, 0xaa, 0xce, 0xfe, 0x44, 0x5f, 0x7d, 0xfc, 0x1f, 0xac, 0x93, 0x24, 0xa1, 0xd1, 0x35, 0xae,
	0x1d, 0xb8, 0x5e, 0xe9, 0x82, 0x38, 0x15, 0xd7, 0x40, 0x17, 0xcc, 0x0b, 0x2a, 0xb0, 0x95, 0x3f,
	0xe8, 0x63, 0xdd, 0xdb, 0x2f, 0xc9, 0x29, 0x16, 0x07, 0x50, 0x1b, 0x4b, 0x7e, 0xb3, 0x95, 0xd7,
	0x77, 0xd0, 0x28, 0xac, 0x34, 0x1e, 0xe4, 0x80, 0xf2, 0x9e, 0xaf, 0x1a, 0xa6, 0x66, 0x85, 0xad,
	0x5c, 0x9a, 0x95, 0x57, 0x75, 0xcd, 0x6c, 0x08, 0xf6, 0x44, 0x4e, 0xb9, 0xcf, 0x82, 0x29, 0x5d,
	0x32, 0xd1, 0xb7, 0x7a, 0xc9, 0x24, 0xbb, 0xa9, 0x4e, 0x05, 0x5f, 0xa5, 0x4c, 0xc2, 0x10, 0x1f,
	0x9f, 0xb2, 0x6b, 0xd7, 0x5b, 0xa3, 0xe6, 0x54, 0x5e, 0x1b, 0x53, 0x4b, 0xfd, 0x47, 0xdf, 0xfe,
	0x09, 0x00, 0x00, 0xff, 0xff, 0x26, 0x5c, 0x8b, 0x8f, 0x5f, 0x07, 0x00, 0x00,
}
